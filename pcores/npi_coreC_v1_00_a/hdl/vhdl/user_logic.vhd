-- File automatically generated by: PandA framework version=0.8.0c1
-- Send any bug to: ferrandi@elet.polimi.it
-- ************************************************************************
-- The following text holds for all the components tagged with PANDA_GPLv3.
-- 
-- This hardware description is free; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
-- 
-- This hardware description is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with the bambu program; see the files COPYING3
-- If not, see <http://www.gnu.org/licenses/>.
-- ************************************************************************

-- 
-- 
-- Author(s): 
-- License: 
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
library proc_common_v3_00_a;
use proc_common_v3_00_a.proc_common_pkg.all;
library work;
entity user_logic is 
generic(
C_PI_ADDR_WIDTH : integer := 32;
C_PI_DATA_WIDTH : integer := 64;
C_PI_BE_WIDTH : integer := 8;
C_PI_RDWDADDR_WIDTH : integer := 4;
ADDR_WIDTH : integer := 32;
DATA_WIDTH : integer := 64;
C_SLV_DWIDTH : integer := 32;
C_NUM_REG : integer := 4);
port (
  -- IN
  XIL_NPI_AddrAck : in std_logic := '0';
  XIL_NPI_RdFIFO_Data : in std_logic_vector (C_PI_DATA_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_RdFIFO_RdWdAddr : in std_logic_vector (C_PI_RDWDADDR_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Empty : in std_logic := '0';
  XIL_NPI_WrFIFO_AlmostFull : in std_logic := '0';
  XIL_NPI_RdFIFO_Empty : in std_logic := '0';
  XIL_NPI_RdFIFO_Latency : in std_logic_vector (1 downto 0) := (others => '0');
  XIL_NPI_InitDone : in std_logic := '0';
  XIL_NPI_Clk : in std_logic := '0';
  XIL_NPI_Rst : in std_logic := '0';
  Bus2IP_Clk : in std_logic := '0';
  Bus2IP_Reset : in std_logic := '0';
  Bus2IP_Data : in std_logic_vector (0 to C_SLV_DWIDTH-1) := (others => '0');
  Bus2IP_BE : in std_logic_vector (0 to C_SLV_DWIDTH/8-1) := (others => '0');
  Bus2IP_RdCE : in std_logic_vector (0 to C_NUM_REG-1) := (others => '0');
  Bus2IP_WrCE : in std_logic_vector (0 to C_NUM_REG-1) := (others => '0');
  -- OUT
  XIL_NPI_Addr : out std_logic_vector (C_PI_ADDR_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_AddrReq : out std_logic := '0';
  XIL_NPI_RNW : out std_logic := '0';
  XIL_NPI_Size : out std_logic_vector (3 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Data : out std_logic_vector (C_PI_DATA_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_BE : out std_logic_vector (C_PI_BE_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Push : out std_logic := '0';
  XIL_NPI_RdFIFO_Pop : out std_logic := '0';
  XIL_NPI_WrFIFO_Flush : out std_logic := '0';
  XIL_NPI_RdFIFO_Flush : out std_logic := '0';
  XIL_NPI_RdModWr : out std_logic := '0';
  INT_DONE : out std_logic := '0';
  IP2Bus_Data : out std_logic_vector (0 to C_SLV_DWIDTH-1) := (others => '0');
  IP2Bus_RdAck : out std_logic := '0';
  IP2Bus_WrAck : out std_logic := '0';
  IP2Bus_Error : out std_logic := '0'
);
end user_logic;

architecture user_logic_arch of user_logic is
  signal slv_reg0                       : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_reg1                       : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_reg2                       : std_logic_vector(0 to C_SLV_DWIDTH-1); -- a
  signal slv_reg3                       : std_logic_vector(0 to C_SLV_DWIDTH-1); -- b
  signal slv_reg_write_sel              : std_logic_vector(0 to 3);
  signal slv_reg_read_sel               : std_logic_vector(0 to 3);
  signal slv_ip2bus_data                : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_read_ack                   : std_logic;
  signal slv_write_ack                  : std_logic;
  signal done_port                      : std_logic;
  signal start                          : std_logic;
  signal return_port_sig                : signed (31 downto 0);
  signal return_port                    : std_logic_vector(0 to 31);
  signal a_sig : signed (31 downto 0);
  signal b_sig : signed (31 downto 0);
  component coreC is
   port(
      clock : in std_logic;
      reset : in std_logic;
      start_port : in std_logic;
      a : in signed (31 downto 0);
      b : in signed (31 downto 0);
      done_port : out std_logic;
      return_port : out signed (31 downto 0)
   );
  end component;
  begin
  slv_reg_write_sel <= Bus2IP_WrCE(0 to 3);
  slv_reg_read_sel <= Bus2IP_RdCE(0 to 3);
  slv_write_ack <= Bus2IP_WrCE(0) or Bus2IP_WrCE(1) or Bus2IP_WrCE(2) or Bus2IP_WrCE(3);
  slv_read_ack <= Bus2IP_RdCE(0) or Bus2IP_RdCE(1) or Bus2IP_RdCE(2) or Bus2IP_RdCE(3);
  -- implement slave model software accessible register(s)
    SLAVE_REG_WRITE_PROC : process( Bus2IP_Clk ) is
    begin
      if Bus2IP_Clk'event and Bus2IP_Clk = '1' then
        if Bus2IP_Reset = '1' then
          slv_reg0 <= (others => '0');
          slv_reg1 <= (others => '0');
          slv_reg2 <= (others => '0');
          slv_reg3 <= (others => '0');
        else
          slv_reg0(0) <= '0';
          slv_reg0(1) <= '0';
          slv_reg0(4) <= '0';
          -- Return Port
          if (done_port = '1') then
            slv_reg1 <= return_port;
            slv_reg0(5) <= '1';
          end if;
          case slv_reg_write_sel is
            when "1000" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg0(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "0100" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg1(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "0010" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg2(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "0001" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg3(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when others => null;
          end case;
        end if;
      end if;
    end process SLAVE_REG_WRITE_PROC;
    -- implement slave model software accessible register(s) read mux
    SLAVE_REG_READ_PROC : process( slv_reg_read_sel, slv_reg0, slv_reg1, slv_reg2, slv_reg3) is
    begin
      case slv_reg_read_sel is
        when "1000" => slv_ip2bus_data <= slv_reg0;
        when "0100" => slv_ip2bus_data <= slv_reg1;
        when "0010" => slv_ip2bus_data <= slv_reg2;
        when "0001" => slv_ip2bus_data <= slv_reg3;
        when others => slv_ip2bus_data <= (others => '0');
      end case;
    end process SLAVE_REG_READ_PROC;
  
    INT_DONE <= done_port;
    -- Control Signal
    start <= slv_reg0(4);
    -- Input Signal Assignation
    a_sig <= signed(slv_reg2);
    b_sig <= signed(slv_reg3);
    -- Return Port
    return_port <= conv_std_logic_vector(return_port_sig, 32);
  
    CORE: coreC
    port map(
            clock => Bus2IP_Clk,
            reset => Bus2IP_Reset,
            start_port => start,
            a => a_sig,
            b => b_sig,
            done_port => done_port,
            return_port => return_port_sig
    );
  
    ------------------------------------------
    -- Code to drive IP to Bus signals
    ------------------------------------------
    IP2Bus_Data  <= slv_ip2bus_data when slv_read_ack = '1' else (others => '0');
    IP2Bus_WrAck <= slv_write_ack;
    IP2Bus_RdAck <= slv_read_ack;
    IP2Bus_Error <= '0';

end user_logic_arch;

