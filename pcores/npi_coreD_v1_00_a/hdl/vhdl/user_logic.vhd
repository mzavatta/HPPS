-- File automatically generated by: PandA framework version=0.8.0c1
-- Send any bug to: ferrandi@elet.polimi.it
-- ************************************************************************
-- The following text holds for all the components tagged with PANDA_GPLv3.
-- 
-- This hardware description is free; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
-- 
-- This hardware description is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.
-- 
-- You should have received a copy of the GNU General Public License
-- along with the bambu program; see the files COPYING3
-- If not, see <http://www.gnu.org/licenses/>.
-- ************************************************************************

-- 
-- 
-- Author(s): 
-- License: 
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
library proc_common_v3_00_a;
use proc_common_v3_00_a.proc_common_pkg.all;
library work;
entity user_logic is 
generic(
C_PI_ADDR_WIDTH : integer := 32;
C_PI_DATA_WIDTH : integer := 64;
C_PI_BE_WIDTH : integer := 8;
C_PI_RDWDADDR_WIDTH : integer := 4;
ADDR_WIDTH : integer := 32;
DATA_WIDTH : integer := 64;
C_SLV_DWIDTH : integer := 32;
C_NUM_REG : integer := 5);
port (
  -- IN
  XIL_NPI_AddrAck : in std_logic := '0';
  XIL_NPI_RdFIFO_Data : in std_logic_vector (C_PI_DATA_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_RdFIFO_RdWdAddr : in std_logic_vector (C_PI_RDWDADDR_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Empty : in std_logic := '0';
  XIL_NPI_WrFIFO_AlmostFull : in std_logic := '0';
  XIL_NPI_RdFIFO_Empty : in std_logic := '0';
  XIL_NPI_RdFIFO_Latency : in std_logic_vector (1 downto 0) := (others => '0');
  XIL_NPI_InitDone : in std_logic := '0';
  XIL_NPI_Clk : in std_logic := '0';
  XIL_NPI_Rst : in std_logic := '0';
  Bus2IP_Clk : in std_logic := '0';
  Bus2IP_Reset : in std_logic := '0';
  Bus2IP_Data : in std_logic_vector (0 to C_SLV_DWIDTH-1) := (others => '0');
  Bus2IP_BE : in std_logic_vector (0 to C_SLV_DWIDTH/8-1) := (others => '0');
  Bus2IP_RdCE : in std_logic_vector (0 to C_NUM_REG-1) := (others => '0');
  Bus2IP_WrCE : in std_logic_vector (0 to C_NUM_REG-1) := (others => '0');
  -- OUT
  XIL_NPI_Addr : out std_logic_vector (C_PI_ADDR_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_AddrReq : out std_logic := '0';
  XIL_NPI_RNW : out std_logic := '0';
  XIL_NPI_Size : out std_logic_vector (3 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Data : out std_logic_vector (C_PI_DATA_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_BE : out std_logic_vector (C_PI_BE_WIDTH-1 downto 0) := (others => '0');
  XIL_NPI_WrFIFO_Push : out std_logic := '0';
  XIL_NPI_RdFIFO_Pop : out std_logic := '0';
  XIL_NPI_WrFIFO_Flush : out std_logic := '0';
  XIL_NPI_RdFIFO_Flush : out std_logic := '0';
  XIL_NPI_RdModWr : out std_logic := '0';
  INT_DONE : out std_logic := '0';
  IP2Bus_Data : out std_logic_vector (0 to C_SLV_DWIDTH-1) := (others => '0');
  IP2Bus_RdAck : out std_logic := '0';
  IP2Bus_WrAck : out std_logic := '0';
  IP2Bus_Error : out std_logic := '0'
);
end user_logic;

architecture user_logic_arch of user_logic is
  signal slv_reg0                       : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_reg1                       : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_reg2                       : std_logic_vector(0 to C_SLV_DWIDTH-1); -- a
  signal slv_reg3                       : std_logic_vector(0 to C_SLV_DWIDTH-1); -- b
  signal slv_reg4                       : std_logic_vector(0 to C_SLV_DWIDTH-1); -- c
  signal slv_reg_write_sel              : std_logic_vector(0 to 4);
  signal slv_reg_read_sel               : std_logic_vector(0 to 4);
  signal slv_ip2bus_data                : std_logic_vector(0 to C_SLV_DWIDTH-1);
  signal slv_read_ack                   : std_logic;
  signal slv_write_ack                  : std_logic;
  signal done_port                      : std_logic;
  signal start                          : std_logic;
  signal return_port                    : std_logic_vector(0 to 31);
  signal a_sig : signed (31 downto 0);
  signal b_sig : signed (31 downto 0);
  signal c_sig : std_logic_vector (31 downto 0);
  signal Bridge2Core_data_r             : std_logic_vector(63 downto 0);
  signal Bridge2Core_ready              : std_logic;
  signal Bridge2Core_LOAD               : std_logic;
  signal Bridge2Core_size               : std_logic_vector(7 downto 0);
  signal core2Bridge_LOAD               : std_logic;
  signal core2Bridge_STORE              : std_logic;
  signal core2Bridge_addr               : std_logic_vector(31 downto 0);
  signal Bridge2Core_STORE              : std_logic;
  signal Bridge2Core_addr               : std_logic_vector(31 downto 0);
  signal Bridge2Core_data_w             : std_logic_vector(63 downto 0);
  signal core2Bridge_data_w             : std_logic_vector(63 downto 0);
  signal core2Bridge_size               : std_logic_vector(7 downto 0);
  signal XIL_NPI_Addr_i                 : std_logic_vector(C_PI_ADDR_WIDTH-1 downto 0);
  signal XIL_NPI_WrFIFO_Data_i          : std_logic_vector(63 downto 0);
  signal XIL_NPI_WrFIFO_Push_i          : std_logic;
  signal XIL_NPI_AddrReq_i              : std_logic;
  signal XIL_NPI_RdFIFO_Pop_i           : std_logic;
  component coreD is
   port(
      clock : in std_logic;
      reset : in std_logic;
      start_port : in std_logic;
      a : in signed (31 downto 0);
      b : in signed (31 downto 0);
      c : in std_logic_vector (31 downto 0);
      M_Rdata_ram : in std_logic_vector (63 downto 0);
      M_DataRdy : in std_logic;
      Min_oe_ram : in std_logic;
      Min_we_ram : in std_logic;
      Min_addr_ram : in std_logic_vector (31 downto 0);
      Min_Wdata_ram : in std_logic_vector (63 downto 0);
      Min_data_ram_size : in std_logic_vector (7 downto 0);
      done_port : out std_logic;
      Mout_oe_ram : out std_logic;
      Mout_we_ram : out std_logic;
      Mout_addr_ram : out std_logic_vector (31 downto 0);
      Mout_Wdata_ram : out std_logic_vector (63 downto 0);
      Mout_data_ram_size : out std_logic_vector (7 downto 0)
   );
  end component;
  begin
  slv_reg_write_sel <= Bus2IP_WrCE(0 to 4);
  slv_reg_read_sel <= Bus2IP_RdCE(0 to 4);
  slv_write_ack <= Bus2IP_WrCE(0) or Bus2IP_WrCE(1) or Bus2IP_WrCE(2) or Bus2IP_WrCE(3) or Bus2IP_WrCE(4);
  slv_read_ack <= Bus2IP_RdCE(0) or Bus2IP_RdCE(1) or Bus2IP_RdCE(2) or Bus2IP_RdCE(3) or Bus2IP_RdCE(4);
  -- implement slave model software accessible register(s)
    SLAVE_REG_WRITE_PROC : process( Bus2IP_Clk ) is
    begin
      if Bus2IP_Clk'event and Bus2IP_Clk = '1' then
        if Bus2IP_Reset = '1' then
          slv_reg0 <= (others => '0');
          slv_reg1 <= (others => '0');
          slv_reg2 <= (others => '0');
          slv_reg3 <= (others => '0');
          slv_reg4 <= (others => '0');
        else
          slv_reg0(0) <= '0';
          slv_reg0(1) <= '0';
          slv_reg0(4) <= '0';
          -- Return Port
          if (done_port = '1') then
            slv_reg0(5) <= '1';
          end if;
          case slv_reg_write_sel is
            when "10000" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg0(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "00100" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg2(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "00010" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg3(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when "00001" => 
              for byte_index in 0 to (C_SLV_DWIDTH/8)-1 loop
                if ( Bus2IP_BE(byte_index) = '1' ) then
                  slv_reg4(byte_index*8 to byte_index*8+7) <= Bus2IP_Data(byte_index*8 to byte_index*8+7);
                end if;
              end loop;
            when others => null;
          end case;
        end if;
      end if;
    end process SLAVE_REG_WRITE_PROC;
    -- implement slave model software accessible register(s) read mux
    SLAVE_REG_READ_PROC : process( slv_reg_read_sel, slv_reg0, slv_reg1, slv_reg2, slv_reg3, slv_reg4) is
    begin
      case slv_reg_read_sel is
        when "10000" => slv_ip2bus_data <= slv_reg0;
        when "01000" => slv_ip2bus_data <= slv_reg1;
        when "00100" => slv_ip2bus_data <= slv_reg2;
        when "00010" => slv_ip2bus_data <= slv_reg3;
        when "00001" => slv_ip2bus_data <= slv_reg4;
        when others => slv_ip2bus_data <= (others => '0');
      end case;
    end process SLAVE_REG_READ_PROC;
  
    INT_DONE <= done_port;
    -- Control Signal
    start <= slv_reg0(4);
    -- Input Signal Assignation
    a_sig <= signed(slv_reg2);
    b_sig <= signed(slv_reg3);
    c_sig <= slv_reg4;
    return_port <= (others => '0');
  
  
    CORE: coreD
    port map(
            clock => Bus2IP_Clk,
            reset => Bus2IP_Reset,
            start_port => start,
            a => a_sig,
            b => b_sig,
            c => c_sig,
            M_Rdata_ram => Bridge2Core_data_r,
            M_DataRdy => Bridge2Core_ready,
            Min_oe_ram => Bridge2Core_LOAD,
            Min_we_ram => Bridge2Core_STORE,
            Min_addr_ram => Bridge2Core_addr,
            Min_Wdata_ram => Bridge2Core_data_w,
            Min_data_ram_size => Bridge2Core_size,
            done_port => done_port,
            Mout_oe_ram => core2Bridge_LOAD,
            Mout_we_ram => core2Bridge_STORE,
            Mout_addr_ram => core2Bridge_addr,
            Mout_Wdata_ram => core2Bridge_data_w,
            Mout_data_ram_size => core2Bridge_size
    );
  
    TOP: entity work.TOP_bridge(structural)
    generic map(
                C_PI_ADDR_WIDTH           => C_PI_ADDR_WIDTH,
                C_PI_DATA_WIDTH           => C_PI_DATA_WIDTH,
                C_PI_BE_WIDTH             => C_PI_BE_WIDTH,
                C_PI_RDWDADDR_WIDTH       => C_PI_RDWDADDR_WIDTH,
                ADDR_WIDTH                => ADDR_WIDTH,
                DATA_WIDTH                => DATA_WIDTH,
                INITIAL_ADDRESS_RANGE     => X"00000000",
                FINAL_ADDRESS_RANGE       => X"0FFFFFFF",
                BURST_LENGTH              => "0000"
           )
    port map(
            CLK => Bus2IP_Clk,
            RESET => Bus2IP_Reset,
            -- Input Chain Interface
            S_in_addr => core2Bridge_addr,
            S_in_size => core2Bridge_size,
            S_in_data_w => core2Bridge_data_w,
            S_in_LOAD => core2Bridge_LOAD,
            S_in_STORE => core2Bridge_STORE,
            -- Output Chain Interface
            S_out_addr => Bridge2Core_addr,
            S_out_size => Bridge2Core_size,
            S_out_data_w => Bridge2Core_data_w,
            S_out_data_r => Bridge2Core_data_r,
            S_out_ready => Bridge2Core_ready,
            S_out_LOAD => Bridge2Core_LOAD,
            S_out_STORE => Bridge2Core_STORE,
            -- MPMC Port Interface - Bus is prefixed with NPI_ . Outputs Directly connected to the MPMC
            XIL_NPI_Addr              => XIL_NPI_Addr_i,
            XIL_NPI_AddrReq           => XIL_NPI_AddrReq_i,
            XIL_NPI_AddrAck           => XIL_NPI_AddrAck,
            XIL_NPI_RNW               => XIL_NPI_RNW,
            XIL_NPI_Size              => XIL_NPI_Size,
            XIL_NPI_WrFIFO_Data       => XIL_NPI_WrFIFO_Data_i,
            XIL_NPI_WrFIFO_BE         => XIL_NPI_WrFIFO_BE,
            XIL_NPI_WrFIFO_Push       => XIL_NPI_WrFIFO_Push_i,
            XIL_NPI_RdFIFO_Data       => XIL_NPI_RdFIFO_Data,
            XIL_NPI_RdFIFO_Pop        => XIL_NPI_RdFIFO_Pop_i,
            XIL_NPI_RdFIFO_RdWdAddr   => XIL_NPI_RdFIFO_RdWdAddr,
            XIL_NPI_WrFIFO_Empty      => XIL_NPI_WrFIFO_Empty,
            XIL_NPI_WrFIFO_AlmostFull => XIL_NPI_WrFIFO_AlmostFull,
            XIL_NPI_WrFIFO_Flush      => XIL_NPI_WrFIFO_Flush,
            XIL_NPI_RdFIFO_Empty      => XIL_NPI_RdFIFO_Empty,
            XIL_NPI_RdFIFO_Flush      => XIL_NPI_RdFIFO_Flush,
            XIL_NPI_RdFIFO_Latency    => XIL_NPI_RdFIFO_Latency,
            XIL_NPI_RdModWr           => XIL_NPI_RdModWr,
            XIL_NPI_InitDone          => XIL_NPI_InitDone,
            XIL_NPI_Clk               => XIL_NPI_Clk,
            XIL_NPI_Rst               => XIL_NPI_Rst
    );
  
    XIL_NPI_Addr           <= XIL_NPI_Addr_i;
    XIL_NPI_AddrReq        <= XIL_NPI_AddrReq_i;
    XIL_NPI_RdFIFO_Pop     <= XIL_NPI_RdFIFO_Pop_i;
    XIL_NPI_WrFIFO_Data    <= XIL_NPI_WrFIFO_Data_i;
    XIL_NPI_WrFIFO_Push    <= XIL_NPI_WrFIFO_Push_i;
    ------------------------------------------
    -- Code to drive IP to Bus signals
    ------------------------------------------
    IP2Bus_Data  <= slv_ip2bus_data when slv_read_ack = '1' else (others => '0');
    IP2Bus_WrAck <= slv_write_ack;
    IP2Bus_RdAck <= slv_read_ack;
    IP2Bus_Error <= '0';

end user_logic_arch;

