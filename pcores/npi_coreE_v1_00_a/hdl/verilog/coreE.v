// File automatically generated by: PandA framework version=0.8.0c1
// Send any bug to: ferrandi@elet.polimi.it
// ************************************************************************
// The following text holds for all the components tagged with PANDA_GPLv3.
// 
// This hardware description is free; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// This hardware description is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
// 
// You should have received a copy of the GNU General Public License
// along with the bambu program; see the files COPYING3
// If not, see <http://www.gnu.org/licenses/>.
// ************************************************************************

// This component is part of the BAMBU/PANDA IP LIBRARY
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): Fabrizio Ferrandi <ferrandi@elet.polimi.it>, Christian Pilato <pilato@elet.polimi.it>
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module constant_value(out1);
  parameter BITSIZE_out1=32, value=32'b00000000000000000000000000000001;
  // OUT
  output [BITSIZE_out1-1:0] out1;
  assign out1 = value;
endmodule

// This component is part of the BAMBU/PANDA IP LIBRARY
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): Fabrizio Ferrandi <ferrandi@elet.polimi.it>, Christian Pilato <pilato@elet.polimi.it>
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module register_FU(in1, wenable, clock, reset, out1);
  parameter BITSIZE_in1=32, BITSIZE_out1=32;
  // IN
  input [BITSIZE_in1-1:0] in1;
  input wenable;
  input clock;
  input reset;
  // OUT
  output [BITSIZE_out1-1:0] out1;
  reg [BITSIZE_out1-1:0] reg_out1;
  assign out1 = reg_out1;
  always @(posedge clock or posedge reset)
    if (reset)
      reg_out1 <= {BITSIZE_out1{1'b0}};
    else if (wenable)
      reg_out1 <= in1;
endmodule

// This component is part of the BAMBU/PANDA IP LIBRARY
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): Fabrizio Ferrandi <ferrandi@elet.polimi.it>
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module plus_expr_FU(in1, in2, out1);
  parameter BITSIZE_in1=32, BITSIZE_in2=32, BITSIZE_out1=32;
  // IN
  input [BITSIZE_in1-1:0] in1;
  input [BITSIZE_in2-1:0] in2;
  // OUT
  output [BITSIZE_out1-1:0] out1;
  assign out1 = in1 + in2;
endmodule

// This component is part of the BAMBU/PANDA IP LIBRARY
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): Fabrizio Ferrandi <ferrandi@elet.polimi.it>
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module MEMORY_CTRL(clock, start_port, in1, in2, in3, sel_LOAD, sel_STORE, done_port, out1, Min_oe_ram, Mout_oe_ram, Min_we_ram, Mout_we_ram, Min_addr_ram, Mout_addr_ram, M_Rdata_ram, Min_Wdata_ram, Mout_Wdata_ram, Min_data_ram_size, Mout_data_ram_size, M_DataRdy);
  parameter BITSIZE_in1=1, BITSIZE_in2=32, BITSIZE_in3=8, BITSIZE_out1=32, BITSIZE_Min_addr_ram=32, BITSIZE_Mout_addr_ram=32, BITSIZE_M_Rdata_ram=64, BITSIZE_Min_Wdata_ram=64, BITSIZE_Mout_Wdata_ram=64;
  // IN
  input clock;
  input start_port;
  input [BITSIZE_in1-1:0] in1;
  input [BITSIZE_in2-1:0] in2;
  input [BITSIZE_in3-1:0] in3;
  input sel_LOAD;
  input sel_STORE;
  input Min_oe_ram;
  input Min_we_ram;
  input [BITSIZE_Min_addr_ram-1:0] Min_addr_ram;
  input [BITSIZE_M_Rdata_ram-1:0] M_Rdata_ram;
  input [BITSIZE_Min_Wdata_ram-1:0] Min_Wdata_ram;
  input [7:0] Min_data_ram_size;
  input M_DataRdy;
  // OUT
  output done_port;
  output [BITSIZE_out1-1:0] out1;
  output Mout_oe_ram;
  output Mout_we_ram;
  output [BITSIZE_Mout_addr_ram-1:0] Mout_addr_ram;
  output [BITSIZE_Mout_Wdata_ram-1:0] Mout_Wdata_ram;
  output [7:0] Mout_data_ram_size;
  assign Mout_addr_ram = (sel_LOAD || sel_STORE) ? (in2) : Min_addr_ram;
  assign Mout_oe_ram = sel_LOAD ? 1'b1 : Min_oe_ram;
  assign Mout_we_ram = sel_STORE ? 1'b1 : Min_we_ram;
  assign out1 = M_Rdata_ram[BITSIZE_out1-1:0];
  assign Mout_Wdata_ram = sel_STORE ? in1 : Min_Wdata_ram;
  assign Mout_data_ram_size = sel_STORE || sel_LOAD ? in3[7:0] : Min_data_ram_size;
  assign done_port = M_DataRdy;
  // Add assertion here
  // psl default clock = (posedge clock);
  // psl ERROR_LOAD_Min_oe_ram: assert never {sel_LOAD && Min_oe_ram};
  // psl ERROR_STORE_Min_we_ram: assert never {sel_STORE && Min_we_ram};
  // psl ERROR_STORE_LOAD: assert never {sel_STORE && sel_LOAD};
endmodule

// This component is part of the BAMBU/PANDA IP LIBRARY
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): Fabrizio Ferrandi <ferrandi@elet.polimi.it>, Christian Pilato <pilato@elet.polimi.it>
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module MUX_GATE(sel, in1, in2, out1);
  parameter BITSIZE_in1=32, BITSIZE_in2=32, BITSIZE_out1=32;
  // IN
  input sel;
  input [BITSIZE_in1-1:0] in1;
  input [BITSIZE_in2-1:0] in2;
  // OUT
  output [BITSIZE_out1-1:0] out1;
  assign out1 = sel ? in1 : in2;
endmodule

// Datapath RTL descrition for coreE
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): module automatically generated by bambu
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module datapath_coreE(clock, reset, in_port_a, return_port, M_Rdata_ram, M_DataRdy, Min_oe_ram, Min_we_ram, Min_addr_ram, Min_Wdata_ram, Min_data_ram_size, Mout_oe_ram, Mout_we_ram, Mout_addr_ram, Mout_Wdata_ram, Mout_data_ram_size, wrenable_reg_0, fuselector_MEMORY_CTRL_4_0_LOAD, fuselector_MEMORY_CTRL_4_0_STORE, selector_MUX_0_reg_0_0_0_0, selector_IN_UNBOUNDED_coreE_214_220, OUT_UNBOUNDED_coreE_214_220);
  // IN
  input clock;
  input reset;
  input [31:0] in_port_a;
  input [63:0] M_Rdata_ram;
  input M_DataRdy;
  input Min_oe_ram;
  input Min_we_ram;
  input [31:0] Min_addr_ram;
  input [63:0] Min_Wdata_ram;
  input [7:0] Min_data_ram_size;
  input wrenable_reg_0;
  input fuselector_MEMORY_CTRL_4_0_LOAD;
  input fuselector_MEMORY_CTRL_4_0_STORE;
  input selector_MUX_0_reg_0_0_0_0;
  input selector_IN_UNBOUNDED_coreE_214_220;
  // OUT
  output signed [31:0] return_port;
  output Mout_oe_ram;
  output Mout_we_ram;
  output [31:0] Mout_addr_ram;
  output [63:0] Mout_Wdata_ram;
  output [7:0] Mout_data_ram_size;
  output OUT_UNBOUNDED_coreE_214_220;
  // Component and signal declarations
  wire [31:0] out_MUX_0_reg_0_0_0_0;
  wire [31:0] out_const_0;
  wire [7:0] out_const_1;
  wire [31:0] out_fu_coreE_214_220;
  wire [31:0] out_fu_coreE_214_221;
  wire [31:0] out_reg_0;
  wire s_done_fu_coreE_214_220;
  
  MUX_GATE #(.BITSIZE_in1(32), .BITSIZE_in2(32), .BITSIZE_out1(32)) MUX_0_reg_0_0_0_0 (.out1(out_MUX_0_reg_0_0_0_0), .sel(selector_MUX_0_reg_0_0_0_0), .in1(out_fu_coreE_214_220), .in2(out_fu_coreE_214_221));
  constant_value #(.BITSIZE_out1(32), .value(32'b00000000000000000000000000000001)) const_0 (.out1(out_const_0));
  constant_value #(.BITSIZE_out1(8), .value(8'b00100000)) const_1 (.out1(out_const_1));
  MEMORY_CTRL #(.BITSIZE_in1(1), .BITSIZE_in2(32), .BITSIZE_in3(8), .BITSIZE_out1(32), .BITSIZE_Min_addr_ram(32), .BITSIZE_Mout_addr_ram(32), .BITSIZE_M_Rdata_ram(64), .BITSIZE_Min_Wdata_ram(64), .BITSIZE_Mout_Wdata_ram(64)) fu_coreE_214_220 (.done_port(s_done_fu_coreE_214_220), .out1(out_fu_coreE_214_220), .Mout_oe_ram(Mout_oe_ram), .Mout_we_ram(Mout_we_ram), .Mout_addr_ram(Mout_addr_ram), .Mout_Wdata_ram(Mout_Wdata_ram), .Mout_data_ram_size(Mout_data_ram_size), .clock(clock), .start_port(selector_IN_UNBOUNDED_coreE_214_220), .in1(1'b0), .in2(in_port_a), .in3(out_const_1), .sel_LOAD(fuselector_MEMORY_CTRL_4_0_LOAD), .sel_STORE(fuselector_MEMORY_CTRL_4_0_STORE), .Min_oe_ram(Min_oe_ram), .Min_we_ram(Min_we_ram), .Min_addr_ram(Min_addr_ram), .M_Rdata_ram(M_Rdata_ram), .Min_Wdata_ram(Min_Wdata_ram), .Min_data_ram_size(Min_data_ram_size), .M_DataRdy(M_DataRdy));
  plus_expr_FU #(.BITSIZE_in1(32), .BITSIZE_in2(32), .BITSIZE_out1(32)) fu_coreE_214_221 (.out1(out_fu_coreE_214_221), .in1(out_reg_0), .in2(out_const_0));
  register_FU #(.BITSIZE_in1(32), .BITSIZE_out1(32)) reg_0 (.out1(out_reg_0), .in1(out_MUX_0_reg_0_0_0_0), .wenable(wrenable_reg_0), .clock(clock), .reset(reset));
  // io-signal post fix
  assign return_port = out_reg_0;
  assign OUT_UNBOUNDED_coreE_214_220 = s_done_fu_coreE_214_220;

endmodule

// FSM based controller descrition for coreE
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): module automatically generated by bambu
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module controller_coreE(done_port, wrenable_reg_0, fuselector_MEMORY_CTRL_4_0_LOAD, fuselector_MEMORY_CTRL_4_0_STORE, selector_MUX_0_reg_0_0_0_0, selector_IN_UNBOUNDED_coreE_214_220, OUT_UNBOUNDED_coreE_214_220, clock, reset, start_port);
  // IN
  input OUT_UNBOUNDED_coreE_214_220;
  input clock;
  input reset;
  input start_port;
  // OUT
  output done_port;
  output wrenable_reg_0;
  output fuselector_MEMORY_CTRL_4_0_LOAD;
  output fuselector_MEMORY_CTRL_4_0_STORE;
  output selector_MUX_0_reg_0_0_0_0;
  output selector_IN_UNBOUNDED_coreE_214_220;
  parameter [1:0] S_0 = 2'd0,
    S_1 = 2'd1,
    S_2 = 2'd2,
    S_3 = 2'd3;
  // synthesis attribute init of _present_state is S_0;
  // synthesis attribute use_sync_reset of _present_state is no;
  reg [1:0] _present_state, _next_state;
  reg done_port;
  reg wrenable_reg_0;
  reg fuselector_MEMORY_CTRL_4_0_LOAD;
  reg fuselector_MEMORY_CTRL_4_0_STORE;
  reg selector_MUX_0_reg_0_0_0_0;
  reg selector_IN_UNBOUNDED_coreE_214_220;
  
  always @(posedge clock or posedge reset)
    if (reset) _present_state <= S_0;
    else _present_state <= _next_state;
  
  always @(_present_state or OUT_UNBOUNDED_coreE_214_220 or start_port)
  begin
    _next_state = S_0;
    done_port = 1'b0;
    wrenable_reg_0 = 1'b0;
    fuselector_MEMORY_CTRL_4_0_LOAD = 1'b0;
    fuselector_MEMORY_CTRL_4_0_STORE = 1'b0;
    selector_MUX_0_reg_0_0_0_0 = 1'b0;
    selector_IN_UNBOUNDED_coreE_214_220 = 1'b0;
    case (_present_state)
      S_0 :
        if(~start_port)
        begin
          _next_state = S_0;
        end
        else
        begin
          wrenable_reg_0 = 1'b1;
          fuselector_MEMORY_CTRL_4_0_LOAD = 1'b1;
          selector_MUX_0_reg_0_0_0_0 = 1'b1;
          selector_IN_UNBOUNDED_coreE_214_220 = 1'b1;
          if (OUT_UNBOUNDED_coreE_214_220 == 1'b0)
            begin
              _next_state = S_1;
            end
          else
            begin
              _next_state = S_2;
            end
        end
      S_1 :
        begin
          wrenable_reg_0 = 1'b1;
          fuselector_MEMORY_CTRL_4_0_LOAD = 1'b1;
          selector_MUX_0_reg_0_0_0_0 = 1'b1;
          if (OUT_UNBOUNDED_coreE_214_220 == 1'b0)
            begin
              _next_state = S_1;
            end
          else
            begin
              _next_state = S_2;
            end
        end
      S_2 :
        begin
          wrenable_reg_0 = 1'b1;
          _next_state = S_3;
        end
      S_3 :
        begin
          _next_state = S_0;
          done_port = 1'b1;
        end
    endcase
  end
endmodule

// Top circuit for coreE
// Copyright (C) 2004-2011 Politecnico di Milano
// Author(s): module automatically generated by bambu
// License: PANDA_GPLv3
`timescale 1ns / 1ps
module coreE(clock, reset, start_port, done_port, a, return_port, M_Rdata_ram, M_DataRdy, Min_oe_ram, Min_we_ram, Min_addr_ram, Min_Wdata_ram, Min_data_ram_size, Mout_oe_ram, Mout_we_ram, Mout_addr_ram, Mout_Wdata_ram, Mout_data_ram_size);
  // IN
  input clock;
  input reset;
  input start_port;
  input [31:0] a;
  input [63:0] M_Rdata_ram;
  input M_DataRdy;
  input Min_oe_ram;
  input Min_we_ram;
  input [31:0] Min_addr_ram;
  input [63:0] Min_Wdata_ram;
  input [7:0] Min_data_ram_size;
  // OUT
  output done_port;
  output signed [31:0] return_port;
  output Mout_oe_ram;
  output Mout_we_ram;
  output [31:0] Mout_addr_ram;
  output [63:0] Mout_Wdata_ram;
  output [7:0] Mout_data_ram_size;
  // Component and signal declarations
  wire OUT_UNBOUNDED_coreE_214_220;
  wire fuselector_MEMORY_CTRL_4_0_LOAD;
  wire fuselector_MEMORY_CTRL_4_0_STORE;
  wire selector_IN_UNBOUNDED_coreE_214_220;
  wire selector_MUX_0_reg_0_0_0_0;
  wire wrenable_reg_0;
  
  controller_coreE Controller_i (.done_port(done_port), .wrenable_reg_0(wrenable_reg_0), .fuselector_MEMORY_CTRL_4_0_LOAD(fuselector_MEMORY_CTRL_4_0_LOAD), .fuselector_MEMORY_CTRL_4_0_STORE(fuselector_MEMORY_CTRL_4_0_STORE), .selector_MUX_0_reg_0_0_0_0(selector_MUX_0_reg_0_0_0_0), .selector_IN_UNBOUNDED_coreE_214_220(selector_IN_UNBOUNDED_coreE_214_220), .OUT_UNBOUNDED_coreE_214_220(OUT_UNBOUNDED_coreE_214_220), .clock(clock), .reset(reset), .start_port(start_port));
  datapath_coreE Datapath_i (.return_port(return_port), .Mout_oe_ram(Mout_oe_ram), .Mout_we_ram(Mout_we_ram), .Mout_addr_ram(Mout_addr_ram), .Mout_Wdata_ram(Mout_Wdata_ram), .Mout_data_ram_size(Mout_data_ram_size), .OUT_UNBOUNDED_coreE_214_220(OUT_UNBOUNDED_coreE_214_220), .clock(clock), .reset(reset), .in_port_a(a), .M_Rdata_ram(M_Rdata_ram), .M_DataRdy(M_DataRdy), .Min_oe_ram(Min_oe_ram), .Min_we_ram(Min_we_ram), .Min_addr_ram(Min_addr_ram), .Min_Wdata_ram(Min_Wdata_ram), .Min_data_ram_size(Min_data_ram_size), .wrenable_reg_0(wrenable_reg_0), .fuselector_MEMORY_CTRL_4_0_LOAD(fuselector_MEMORY_CTRL_4_0_LOAD), .fuselector_MEMORY_CTRL_4_0_STORE(fuselector_MEMORY_CTRL_4_0_STORE), .selector_MUX_0_reg_0_0_0_0(selector_MUX_0_reg_0_0_0_0), .selector_IN_UNBOUNDED_coreE_214_220(selector_IN_UNBOUNDED_coreE_214_220));

endmodule

